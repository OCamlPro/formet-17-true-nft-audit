
\chapter{Contract NftRoot}

\minitoc

\section{Overview}


\issueMajor{No way to get funds back}{
    Tokens sent to the contract are locked forever.
    %
    They are sent when IndexBasis are destroyed and when
    contracts are deployed.
}

\section{Contract Inheritance}


\noindent\begin{tabular}{|l|p{5cm}|}\hline
DataResolver & \\\hline
IndexResolver & \\\hline
\end{tabular}


\section{Variable Definitions}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
uint256 & \_{}totalMinted &  \\\hline
 & & assigned in @1.NftRoot.mintNft\\\hline
 & & used in @1.NftRoot.mintNft\\\hline
 & & used in @1.NftRoot.mintNft\\\hline
address & \_{}addrBasis &  \\\hline
 & & used in @1.NftRoot.destructBasis\\\hline
 & & assigned in @1.NftRoot.deployBasis\\\hline
 & & used in @1.NftRoot.deployBasis\\\hline
\end{tabular}
\fi

\begin{lstlisting}[firstnumber=16]
    uint256 _totalMinted;
\end{lstlisting}

\begin{lstlisting}[firstnumber=17]
    address _addrBasis;
\end{lstlisting}


\section{Constructor Definitions}


\subsection{Constructor}

\issueMinor{Variable initialization}{
    The globals \_totalMinted and \_addrBasis are not initialized.
}

\issueMinor{Code initialization}{
    Anyone can build a NftRoot contract with a fake \_codeData and \_codeIndex ; consider checking the 
    contract hash. 
}

\begin{lstlisting}[firstnumber=19]
    constructor(TvmCell codeIndex, TvmCell codeData) public {
        tvm.accept();
        _codeIndex = codeIndex;
        _codeData = codeData;
    }
\end{lstlisting}

\section{Public Method Definitions}


\subsection{Function deployBasis}

\issueMinor{Constants}{
    Values "0.5 ton", "0.4 ton" and "104" should be defined as constants.
}

\issueMinor{Variable name typo}{
     Variable "codeHasData" should be named "codeHashData". 
}

\begin{itemize}
\item TODO
\end{itemize}

\issueMinor{Unclear behavior}{
    \_addrBasis is updated after a call of deployBasis, hence
    a call of this function forbids the deletion of the previous 
    IndexBasis deployed.
}

\begin{lstlisting}[firstnumber=33]
    function deployBasis(TvmCell codeIndexBasis) public {
        require(msg.value > 0.5 ton, 104);
        uint256 codeHasData = resolveCodeHashData();
        TvmCell state = tvm.buildStateInit({
            contr: IndexBasis,
            varInit: {
                _codeHashData: codeHasData,
                _addrRoot: address(this)
            },
            code: codeIndexBasis
        });
        _addrBasis = new IndexBasis{stateInit: state, value: 0.4 ton}();
    }
\end{lstlisting}

\subsection{Function destructBasis}

\issueCritical{Public visibility}{
    This function can be called by anyone ; the authentification of destruct
    in IndexBasis is useless.
}

\begin{lstlisting}[firstnumber=47]
    function destructBasis() public view {
        IIndexBasis(_addrBasis).destruct();
    }
\end{lstlisting}

\subsection{Function mintNft}

\issueMinor{Constants}{
    Value "1.1 ton" should be defined a constants.
}

\issueMinor{Spurious variable name}{
    \_totalMinted does not represent the total of NFT minted,
    as the contract creation may bounce.
}

\issueMajor{Sender may be null}{
    If a user calls "mintNft", a Data contract is deployed with
    a null owner.
}

\begin{lstlisting}[firstnumber=25]
    function mintNft() public {
        TvmCell codeData = _buildDataCode(address(this));
        TvmCell stateData = _buildDataState(codeData, _totalMinted);
        new Data{stateInit: stateData, value: 1.1 ton}(msg.sender, _codeIndex);

        _totalMinted++;
    }
\end{lstlisting}
